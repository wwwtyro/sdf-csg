var st=Object.defineProperty,nt=Object.defineProperties;var et=Object.getOwnPropertyDescriptors;var Z=Object.getOwnPropertySymbols;var ot=Object.prototype.hasOwnProperty,it=Object.prototype.propertyIsEnumerable;var A=(h,t,s)=>t in h?st(h,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):h[t]=s,F=(h,t)=>{for(var s in t||(t={}))ot.call(t,s)&&A(h,s,t[s]);if(Z)for(var s of Z(t))it.call(t,s)&&A(h,s,t[s]);return h},G=(h,t)=>nt(h,et(t));var x=(h,t,s)=>(A(h,typeof t!="symbol"?t+"":t,s),s);import{f as C,n as rt,c as b,s as N,a as P,m as at,b as L,r as ut,d as ht,e as ct,g as j,h as U,i as v,j as dt,k as q,l as V,o as K,t as S,p as lt,q as H,u as J,v as O,w as mt,x as Q,y as W,z as R,A as ft,R as pt,B as bt,C as gt,D as xt}from"./vendor.351ef72a.js";const Dt=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&e(a)}).observe(document,{childList:!0,subtree:!0});function s(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerpolicy&&(o.referrerPolicy=n.referrerpolicy),n.crossorigin==="use-credentials"?o.credentials="include":n.crossorigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function e(n){if(n.ep)return;n.ep=!0;const o=s(n);fetch(n.href,o)}};Dt();function wt(h,t){return h[0]=Math.abs(t[0]),h[1]=Math.abs(t[1]),h[2]=Math.abs(t[2]),h}function Mt(h,t){return h[0]=Math.abs(t[0]),h[1]=Math.abs(t[1]),h}function B(h,t,s){return Math.max(t,Math.min(s,h))}function T(h,t,s){return h*(1-s)+t*s}const y={points:[[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]],edges:[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]};function vt(h,t){const s=h.shape[0],e=h.shape[1],n=h.shape[2],o=[],a={};function c(r,i,u){if([r,i,u].toString()in a)return a[[r,i,u].toString()];const m=[];y.points.forEach(function(l){m.push(h.get(r+l[0],i+l[1],u+l[2]))});let f=[0,0,0],I=0;return y.edges.forEach(function(l){if(m[l[0]]<t&&m[l[1]]<t||m[l[0]]>=t&&m[l[1]]>=t)return;const g=m[l[1]]-m[l[0]],w=(t-m[l[0]])/g,p=[y.points[l[1]][0]-y.points[l[0]][0],y.points[l[1]][1]-y.points[l[0]][1],y.points[l[1]][2]-y.points[l[0]][2]],M=[y.points[l[0]][0]+p[0]*w,y.points[l[0]][1]+p[1]*w,y.points[l[0]][2]+p[2]*w];f=[f[0]+M[0]+r,f[1]+M[1]+i,f[2]+M[2]+u],I++}),o.push([f[0]/I,f[1]/I,f[2]/I]),a[[r,i,u].toString()]=o.length-1,a[[r,i,u].toString()]}const d=[];for(let r=0;r<s-1;r++)for(let i=0;i<e-1;i++)for(let u=0;u<n-1;u++){const m=h.get(r+0,i+0,u+0)>=t?1:0,f=h.get(r+1,i+0,u+0)>=t?1:0,I=h.get(r+0,i+1,u+0)>=t?1:0,l=h.get(r+0,i+0,u+1)>=t?1:0;if(m+f===1&&i>0&&u>0){const g=c(r+0,i-1,u-1),w=c(r+0,i-1,u+0),p=c(r+0,i+0,u+0),M=c(r+0,i+0,u-1);f<m?(d.push([g,w,p]),d.push([g,p,M])):(d.push([g,p,w]),d.push([g,M,p]))}if(m+I===1&&r>0&&u>0){const g=c(r-1,i+0,u-1),w=c(r+0,i+0,u-1),p=c(r+0,i+0,u+0),M=c(r-1,i+0,u+0);I<m?(d.push([g,w,p]),d.push([g,p,M])):(d.push([g,p,w]),d.push([g,M,p]))}if(m+l===1&&r>0&&i>0){const g=c(r-1,i-1,u+0),w=c(r+0,i-1,u+0),p=c(r+0,i+0,u+0),M=c(r-1,i+0,u+0);l>m?(d.push([g,w,p]),d.push([g,p,M])):(d.push([g,p,w]),d.push([g,M,p]))}}return{positions:o,cells:d}}class _{constructor(){x(this,"_userData",null);x(this,"bounds",{min:C(0,0,0),max:C(0,0,0)})}normal(t,s,e){const n=.001,o=this.density(t,s,e),a=this.density(t+n,s,e),c=this.density(t,s+n,e),d=this.density(t,s,e+n),r=C((a-o)/n,(c-o)/n,(d-o)/n);return rt(b(),r)}generateMesh(t,s){let e=performance.now();const n=this.generateGrid(t,s);console.log(`Grid: ${Math.round(performance.now()-e)} ms`),e=performance.now();const o=vt(n,0);console.log(`Isosurface extraction: ${Math.round(performance.now()-e)} ms`);const a=N(b(),this.bounds.min,[s,s,s]),c=P(b(),this.bounds.max,[s,s,s]),d=N(b(),c,a);for(const u of o.positions)at(u,u,[d[0]/t[0],d[1]/t[1],d[2]/t[2]]),P(u,u,a);const r=[];for(const u of o.positions)r.push(this.normal(u[0],u[1],u[2]));let i=null;if(this.getUserData(0,0,0)!==null){i=[];for(const u of o.positions)i.push(this.getUserData(u[0],u[1],u[2]))}return G(F({},o),{normals:r,userdata:i})}generateGrid(t,s){const e=new Float32Array((t[0]+1)*(t[1]+1)*(t[2]+1)),n=N(b(),this.bounds.min,[s,s,s]),o=P(b(),this.bounds.max,[s,s,s]),a=(o[0]-n[0])/t[0],c=(o[1]-n[1])/t[1],d=(o[2]-n[2])/t[2];for(let r=0;r<t[0]+1;r++){const i=r*a+n[0];for(let u=0;u<t[1]+1;u++){const m=u*c+n[1];for(let f=0;f<t[2]+1;f++){const I=f*d+n[2],l=t[0]*t[2]*u+t[0]*f+r;e[l]=this.density(i,m,I)}}}return{get:(r,i,u)=>e[t[0]*t[2]*i+t[0]*u+r],shape:[t[0]+1,t[1]+1,t[2]+1]}}setUserData(t){return this._userData=t.slice(),this}getUserData(t,s,e){return this._userData}union(t){return new yt(this,t)}subtract(t){return new Ut(t,this)}intersect(t){return new _t(t,this)}smoothUnion(t,s){return new It(this,t,s)}smoothSubtract(t,s){return new St(t,this,s)}smoothIntersect(t,s){return new Ct(this,t,s)}translate(t,s,e){return new $(this,[t,s,e],L(),1)}rotate(t){return new $(this,[0,0,0],t,1)}rotateX(t){return new $(this,[0,0,0],ut(L(),L(),t),1)}rotateY(t){return new $(this,[0,0,0],ht(L(),L(),t),1)}rotateZ(t){return new $(this,[0,0,0],ct(L(),L(),t),1)}scale(t){return new $(this,[0,0,0],L(),t)}round(t){return new Lt(this,t)}}class Ut extends _{constructor(t,s){super();x(this,"density",(t,s,e)=>{const n=this.sdf1.density(t,s,e),o=this.sdf2.density(t,s,e);return Math.max(-n,o)});this.sdf1=t,this.sdf2=s,j(this.bounds.min,s.bounds.min),j(this.bounds.max,s.bounds.max)}getUserData(t,s,e){if(this._userData!==null)return this._userData;const n=this.sdf1.getUserData(t,s,e),o=this.sdf2.getUserData(t,s,e);if(n!==null&&o===null)return n;if(n===null&&o!==null)return o;if(n===null&&o===null)return null;const a=Math.abs(this.sdf1.density(t,s,e)),c=Math.abs(this.sdf2.density(t,s,e)),d=a/(a+c),r=[];for(let i=0;i<n.length;i++)r.push(n[i]+d*(o[i]-n[i]));return r}}class yt extends _{constructor(t,s){super();x(this,"density",(t,s,e)=>{const n=this.sdf1.density(t,s,e),o=this.sdf2.density(t,s,e);return Math.min(n,o)});this.sdf1=t,this.sdf2=s,U(this.bounds.min,t.bounds.min,s.bounds.min),v(this.bounds.max,t.bounds.max,s.bounds.max)}getUserData(t,s,e){if(this._userData!==null)return this._userData;const n=this.sdf1.getUserData(t,s,e),o=this.sdf2.getUserData(t,s,e);if(n!==null&&o===null)return n;if(n===null&&o!==null)return o;if(n===null&&o===null)return null;const a=Math.abs(this.sdf1.density(t,s,e)),c=Math.abs(this.sdf2.density(t,s,e)),d=a/(a+c),r=[];for(let i=0;i<n.length;i++)r.push(n[i]+d*(o[i]-n[i]));return r}}class _t extends _{constructor(t,s){super();x(this,"density",(t,s,e)=>{const n=this.sdf1.density(t,s,e),o=this.sdf2.density(t,s,e);return Math.max(n,o)});this.sdf1=t,this.sdf2=s,v(this.bounds.min,t.bounds.min,s.bounds.min),U(this.bounds.max,t.bounds.max,s.bounds.max)}getUserData(t,s,e){if(this._userData!==null)return this._userData;const n=this.sdf1.getUserData(t,s,e),o=this.sdf2.getUserData(t,s,e);if(n!==null&&o===null)return n;if(n===null&&o!==null)return o;if(n===null&&o===null)return null;const a=Math.abs(this.sdf1.density(t,s,e)),c=Math.abs(this.sdf2.density(t,s,e)),d=a/(a+c),r=[];for(let i=0;i<n.length;i++)r.push(n[i]+d*(o[i]-n[i]));return r}}class St extends _{constructor(t,s,e){super();x(this,"density",(t,s,e)=>{const n=this.sdf1.density(t,s,e),o=this.sdf2.density(t,s,e),a=B(.5-.5*(o+n)/this.smoothness,0,1);return T(o,-n,a)+this.smoothness*a*(1-a)});this.sdf1=t,this.sdf2=s,this.smoothness=e,j(this.bounds.min,s.bounds.min),j(this.bounds.max,s.bounds.max)}getUserData(t,s,e){if(this._userData!==null)return this._userData;const n=this.sdf1.getUserData(t,s,e),o=this.sdf2.getUserData(t,s,e);if(n!==null&&o===null)return n;if(n===null&&o!==null)return o;if(n===null&&o===null)return null;const a=Math.abs(this.sdf1.density(t,s,e)),c=Math.abs(this.sdf2.density(t,s,e)),d=a/(a+c),r=[];for(let i=0;i<n.length;i++)r.push(n[i]+d*(o[i]-n[i]));return r}}class It extends _{constructor(t,s,e){super();x(this,"density",(t,s,e)=>{const n=this.sdf1.density(t,s,e),o=this.sdf2.density(t,s,e),a=B(.5+.5*(o-n)/this.smoothness,0,1);return T(o,n,a)-this.smoothness*a*(1-a)});this.sdf1=t,this.sdf2=s,this.smoothness=e,U(this.bounds.min,t.bounds.min,s.bounds.min),v(this.bounds.max,t.bounds.max,s.bounds.max)}getUserData(t,s,e){if(this._userData!==null)return this._userData;const n=this.sdf1.getUserData(t,s,e),o=this.sdf2.getUserData(t,s,e);if(n!==null&&o===null)return n;if(n===null&&o!==null)return o;if(n===null&&o===null)return null;const a=Math.abs(this.sdf1.density(t,s,e)),c=Math.abs(this.sdf2.density(t,s,e)),d=a/(a+c),r=[];for(let i=0;i<n.length;i++)r.push(n[i]+d*(o[i]-n[i]));return r}}class Ct extends _{constructor(t,s,e){super();x(this,"density",(t,s,e)=>{const n=this.sdf1.density(t,s,e),o=this.sdf2.density(t,s,e),a=B(.5-.5*(o-n)/this.smoothness,0,1);return T(o,n,a)+this.smoothness*a*(1-a)});this.sdf1=t,this.sdf2=s,this.smoothness=e,v(this.bounds.min,t.bounds.min,s.bounds.min),U(this.bounds.max,t.bounds.max,s.bounds.max)}getUserData(t,s,e){if(this._userData!==null)return this._userData;const n=this.sdf1.getUserData(t,s,e),o=this.sdf2.getUserData(t,s,e);if(n!==null&&o===null)return n;if(n===null&&o!==null)return o;if(n===null&&o===null)return null;const a=Math.abs(this.sdf1.density(t,s,e)),c=Math.abs(this.sdf2.density(t,s,e)),d=a/(a+c),r=[];for(let i=0;i<n.length;i++)r.push(n[i]+d*(o[i]-n[i]));return r}}class $ extends _{constructor(t,s,e,n){super();x(this,"matrix");x(this,"density",(t,s,e)=>{const n=C(t,s,e);return S(n,n,this.matrix),this.sdf.density(n[0],n[1],n[2])});this.sdf=t,this.matrix=dt(q(),e,s,C(n,n,n));const o=V(this.sdf.bounds.min),a=V(this.sdf.bounds.max),c=K(b(),a,o),d=P(b(),o,[c[0],0,0]),r=P(b(),o,[c[0],c[1],0]),i=P(b(),o,[0,c[1],0]),u=N(b(),a,[c[0],0,0]),m=N(b(),a,[c[0],c[1],0]),f=N(b(),a,[0,c[1],0]);S(o,o,this.matrix),S(a,a,this.matrix),S(d,d,this.matrix),S(r,r,this.matrix),S(i,i,this.matrix),S(u,u,this.matrix),S(m,m,this.matrix),S(f,f,this.matrix),U(this.bounds.min,o,a),U(this.bounds.min,this.bounds.min,d),U(this.bounds.min,this.bounds.min,r),U(this.bounds.min,this.bounds.min,i),U(this.bounds.min,this.bounds.min,u),U(this.bounds.min,this.bounds.min,m),U(this.bounds.min,this.bounds.min,f),v(this.bounds.max,o,a),v(this.bounds.max,this.bounds.max,d),v(this.bounds.max,this.bounds.max,r),v(this.bounds.max,this.bounds.max,i),v(this.bounds.max,this.bounds.max,u),v(this.bounds.max,this.bounds.max,m),v(this.bounds.max,this.bounds.max,f),lt(this.matrix,this.matrix)}getUserData(t,s,e){if(this._userData!==null)return this._userData;const n=S(b(),[t,s,e],this.matrix);return this.sdf.getUserData(n[0],n[1],n[2])}}class Lt extends _{constructor(t,s){super();x(this,"density",(t,s,e)=>this.sdf.density(t,s,e)-this.radius);this.sdf=t,this.radius=s,N(this.bounds.min,t.bounds.min,[s,s,s]),P(this.bounds.max,t.bounds.max,[s,s,s])}getUserData(t,s,e){return this._userData!==null?this._userData:this.sdf.getUserData(t,s,e)}}class Nt extends _{constructor(t,s,e){super();x(this,"radii");x(this,"density",(t,s,e)=>{const n=C(t,s,e),o=wt(b(),n),a=K(b(),o,this.radii),c=v(b(),a,C(0,0,0));return J(c)+Math.min(Math.max(a[0],Math.max(a[1],a[2])),0)});this.radii=C(t,s,e),H(this.bounds.min,this.radii),j(this.bounds.max,this.radii)}}class Pt extends _{constructor(t){super();x(this,"density",(t,s,e)=>{const n=C(t,s,e);return J(n)-this.radius});this.radius=t,H(this.bounds.min,[this.radius,this.radius,this.radius]),O(this.bounds.max,this.radius,this.radius,this.radius)}}class X extends _{constructor(t,s){super();x(this,"density",(t,s,e)=>{const n=mt(R(),Mt(R(),Q(W([t,e]),s)),Q(this.radius,this.length));return Math.min(Math.max(n[0],n[1]),0)+W(ft(R(),n,[0,0]))});this.length=t,this.radius=s,O(this.bounds.min,-s,-t,-s),O(this.bounds.max,s,t,s)}}const D=pt({extensions:["ANGLE_instanced_arrays","OES_element_index_uint"]}),$t=new Pt(1).setUserData([0,0,1]).smoothIntersect(new Nt(.75,.75,.75).setUserData([1,0,0]),.1).smoothSubtract(new X(1,.5).smoothUnion(new X(1,.5).rotateX(Math.PI/2),.1).smoothUnion(new X(1,.5).rotateZ(Math.PI/2),.1).setUserData([0,1,0]),.1),jt=.2,k=$t.generateMesh([64,64,64],jt),Et={positions:D.buffer(k.positions),colors:D.buffer(k.userdata),normals:D.buffer(k.normals),cells:D.elements(k.cells)},kt=D({vert:`
    precision highp float;
    attribute vec3 position, color, normal;
    uniform mat4 model, view, projection;
    varying vec3 vNormal, vColor;

    void main() {
      gl_Position = projection * view * model * vec4(position, 1.0);
      vNormal = vec3(model * vec4(normal, 1.0));
      vColor = color;
    }
  `,frag:`
    precision highp float;
    varying vec3 vNormal, vColor;

    void main() {
      vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
      float light = 0.5 + 0.5 * dot(normalize(vNormal), lightDir);
      gl_FragColor = vec4(light * vColor,1);
    }
  `,attributes:{position:D.prop("positions"),color:D.prop("colors"),normal:D.prop("normals")},uniforms:{model:D.prop("model"),view:D.prop("view"),projection:D.prop("projection")},viewport:D.prop("viewport"),elements:D.prop("cells"),cull:{enable:!0,face:"back"}}),E=document.getElementsByTagName("canvas")[0];var z=new bt(E,{drag:.01});z.spin(Math.random()*32-16,Math.random()*32-16);let Y=3;window.addEventListener("wheel",h=>{h.deltaY<0?Y*=.95:Y/=.95});function tt(){D.clear({color:[0,0,0,0],depth:1});const h=gt(q(),[0,0,Y],[0,0,0],[0,1,0]),t=xt(q(),Math.PI/4,E.width/E.height,.1,1e3),s={x:0,y:0,width:E.width,height:E.height};kt(G(F({},Et),{model:z.rotation,view:h,projection:t,viewport:s})),requestAnimationFrame(tt)}tt();console.log("done");
